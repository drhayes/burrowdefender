<!DOCTYPE HTML>
<html>
	<head>
		<title>TileMap</title>
		<script type="text/javascript" src="../lib/jquery/jquery-1.4.2.min.js"></script>
		<script type="text/javascript" src="qunit.js"></script>
		<script type="text/javascript" src="../src/tile.js"></script>
		<script type="text/javascript" src="../src/tilemap.js"></script>
		<script type="text/javascript" src="fakes.js"></script>
		<link rel="stylesheet" href="qunit.css" media="screen" title="no title">
		<script type="text/javascript" charset="utf-8">
			$(document).ready(function() {
				module('basics');

				test('ctor', function() {
					ok(typeof(TileMap) !== 'undefined', 'TileMap ctor exists');
					var tm = new TileMap(600, 500);
					ok(tm, 'should get object back');
					ok(tm.tilemap, 'should have a tilemap');
					equals(tm.width, 600, 'tm.width');
					equals(tm.height, 500, 'tm.height');
					// prove that it starts out empty somehow
					var x = 0;
					for (prop in tm.tilemap) {
						x++;
					}
					ok(x === 0, 'the tilemap should be empty');
					ok(typeof(tm.draw) === 'function', 'draw exists');
				});

				test('makekey', function() {
					ok(typeof(TileMap.makekey) == 'function', 'makekey is a function');
					ok(TileMap.makekey(3, 4) === '3:4', '3,4 becomes the key "3:4"');
					ok(TileMap.makekey(-2, 4) === '-2:4', '-2,4 becomes the key "-2:4"');
				});
				
				test('parsekey', function() {
					ok(typeof(TileMap.parsekey) === 'function', 'parsekey is a function');
					var key = TileMap.parsekey('0:0');
					equals(key.x, 0, 'x for key 0:0');
					equals(key.y, 0, 'y for key 0:0');
					key = TileMap.parsekey('-3:-4');
					equals(key.x, -3, 'x for key -3:-4');
					equals(key.y, -4, 'y for key -3:-4');
				});
				
				test('getrect', function() {
					ok(typeof(TileMap.getrect) === 'function', 'getrect is a function');
					var rect = TileMap.getrect(0, 0);
					equals(rect.x1, 0, 'x1');
					equals(rect.y1, 0, 'y1');
					equals(rect.x2, Tile.tilesize - 1, 'x2');
					equals(rect.y2, Tile.tilesize - 1, 'y2');
					rect = TileMap.getrect(1, 1);
					equals(rect.x1, Tile.tilesize, 'x1');
					equals(rect.y1, Tile.tilesize, 'y1');
					equals(rect.x2, Tile.tilesize * 2 - 1, 'x2');
					equals(rect.y2, Tile.tilesize * 2 - 1, 'y2');
				});
				
				module('usage', {
					'setup': function() {
						this.tm = new TileMap();
					}
				});
				
				test('get and set', function() {
					ok(typeof(this.tm.get) == 'function', 'get is a function');
					ok(typeof(this.tm.set) == 'function', 'set is a function');
					ok(this.tm.get(0, 0) === Tile.Air, '0,0 has an Air');
					ok(this.tm.get(3, -2) === Tile.Air, 'gee, looks like it is all Air');
					this.tm.set(0, 0, Tile.Dirt);
					var key = TileMap.makekey(0, 0);
					ok(this.tm.tilemap[key] === Tile.Dirt, 'the dirt tile is in the tilemap');
					ok(this.tm.get(0, 0) === Tile.Dirt, 'the dirt tile we set is gettable');
				});
				
				module('drawing', {
					setup: function() {
						// for the purposes of these tests, Air doesn't have a draw method
						this.olddraw = Tile.Air.draw;
						Tile.Air.draw = function() {};
						this.tm = new TileMap(64, 64);
						this.fakectx = new FakeCtx();
					},
					teardown: function() {
						Tile.Air.draw = this.olddraw;
					}
				})
				
				test('draw with two tiles noscroll', function() {
					this.tm = new TileMap(Tile.tilesize * 4, Tile.tilesize * 4);
					this.tm.set(0, 3, Tile.Dirt);
					this.tm.set(1, 3, Tile.Dirt);
					this.tm.draw(this.fakectx);
					console.log(this.fakectx);
					equals(this.fakectx.fillRectArgs.length, 2, 'called twice');
					var args = this.fakectx.fillRectArgs
					equals(args[0].frx, 0, 'first frx');
					equals(args[0].fry, 3 * Tile.tilesize + 30, 'first fry');
					equals(args[0].frw, Tile.tilesize, 'first frw');
					equals(args[0].frh, 3, 'first frh');
					equals(args[1].frx, 1 * Tile.tilesize, 'second frx');
					equals(args[1].fry, 3 * Tile.tilesize + 30, 'second fry');
					equals(args[1].frw, Tile.tilesize, 'second frw');
					equals(args[1].frh, 3, 'second frh');
				});
				
				test('draw with two tiles scroll tilesize aligned', function() {
					for (var i = 0; i < 5; i++) {
						this.tm.set(i, 0, Tile.Dirt);
					}
					// first test the easy tilesize-aligned version
					this.tm.draw(this.fakectx, 32, 0);
					equals(this.fakectx.fillRectArgs.length, 3, 'called three times');
					var args = this.fakectx.fillRectArgs;
					equals(args[0].frx, 0, 'first frx');
					equals(args[0].fry, 30, 'first fry');
					equals(args[1].frx, Tile.tilesize, 'second frx');
					equals(args[1].fry, 30, 'second fry');
					equals(args[2].frx, 2 * Tile.tilesize, 'third frx');
					equals(args[2].fry, 30, 'third fry');
				});
				
				test('draw with three tiles not tilesize aligned', function() {
					for (var i = 0; i < 5; i++) {
						this.tm.set(i, 0, Tile.Dirt);
					}
					// non tilesize aligned
					this.tm.draw(this.fakectx, 20, 0);
					equals(this.fakectx.fillRectArgs.length, 3, 'called three times');
					var args = this.fakectx.fillRectArgs;
					equals(args[0].frx, -20, 'first frx');
					equals(args[1].frx, -20 + Tile.tilesize, 'second frx');
					equals(args[2].frx, -20 + (Tile.tilesize * 2), 'third frx');
				});
				
				test('mining damage', function() {
					ok(this.tm.miningdamage, 'tm.miningdamage');
					equals(this.tm.miningdamage.x, 0, 'miningdamage.x');
					equals(this.tm.miningdamage.y, 0, 'miningdamage.y');
					equals(this.tm.miningdamage.damage, 0, 'miningdamage.damage');
				});
			});
		</script>
	</head>
	<body>
		<h1 id="qunit-header">TileMap Test</h1>
 		<h2 id="qunit-banner"></h2>
 		<h2 id="qunit-userAgent"></h2>
 		<ol id="qunit-tests"></ol>
 		<div id="qunit-fixture">test markup, will be hidden</div>
	</body>
</html>
